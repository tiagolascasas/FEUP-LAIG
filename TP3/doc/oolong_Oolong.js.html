<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: oolong/Oolong.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: oolong/Oolong.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

/**
  * Represents an Oolong game, managing the connection to the SICStus server,
  * processing the requests and displaying the board
  * @constructor
  * @param {Scene} scene - the scene this Oolong instance is associated to
  */
function Oolong(scene)
{
    this.scene = scene;
    this.graph = scene.objGraph;
    this.cardinals = ['c', 'n', 's', 'e', 'w', 'nw', 'ne', 'sw', 'se'];
    this.matrix = mat4.identity(mat4.create());
    this.cameraAngle = 0;
    this.timeoutValue = 0;
    this.counterTables = new Counter(this.scene, "scenes/textures/label1.png");
    this.counterTimeout = new Counter(this.scene, "scenes/textures/label2.png");

    this.greenPiece = this.graph.getNodeByID("greenPiece");
    this.blackPiece = this.graph.getNodeByID("blackPiece");
    this.table = this.graph.getNodeByID("roundTable");
    this.dish = this.graph.getNodeByID("dish");
    this.sideboard = this.graph.getNodeByID("sideboard");
    this.victorySphereBlack = this.graph.getNodeByID("victorySphereBlack");
    this.victorySphereGreen = this.graph.getNodeByID("victorySphereGreen");

    this.initPositions();
}

/**
  * Initializes a new Oolong match
  * @param {String} mode - the game mode
  * @param {String} difficulty - the AI's difficulty
  * @param {Number} timeout - the human player's turn timeout, in seconds
  */
Oolong.prototype.init = function(mode, difficulty, timeout)
{
    //immutable during the match
    this.mode = mode;
    this.difficulty = difficulty;
    this.timeoutValue = timeout * 1000;

    //(re)set mutable state machine flags to default values
    this.resetState();

    //instantiate the dishes and pieces objects
    this.initPositions();

    //create new state list for undo/redo moves
    this.stateList = new StateList();

    console.clear();
    console.log("Starting " + this.mode + " match with " + this.difficulty + " difficulty and turn timeout " + timeout + "s");

    this.request("reset");
    this.request("init");

    switch (mode)
    {
        case "1vs1":
            this.request("start_1vs1");
            break;
        case "1vsAI":
            this.request("start_1vsAI");
            break;
        case "AIvsAI":
            this.request("start_AIvsAI");
            break;
    }

    switch (difficulty)
    {
        case "Easy":
            this.request("AI_easy");
            break;
        case "Hard":
            this.request("AI_hard");
            break;
    }

    //variables that are not reset every turn change or otherwise need initialization
    this.running = true;
    this.readyForTurn = true;
    this.tablesBlack = 0;
    this.tablesGreen = 0;
    this.cameraAngle = 0;
};

/**
  * Initializes the coordinates of the pieces, tables and dishes
  */
Oolong.prototype.initPositions = function()
{
    const mid = Math.cos(Math.PI / 4);

    this.tables = {};
    this.tables['c'] = new Coord(0, 0, 0);
    this.tables['n'] = new Coord(0, 0, -1.1);
    this.tables['s'] = new Coord(0, 0, 1.1);
    this.tables['e'] = new Coord(1.1, 0, 0);
    this.tables['w'] = new Coord(-1.1, 0, 0);
    this.tables['nw'] = new Coord(-1.1*mid, 0, -1.1*mid);
    this.tables['ne'] = new Coord(1.1*mid, 0, -1.1*mid);
    this.tables['sw'] = new Coord(-1.1*mid, 0, 1.1*mid);
    this.tables['se'] = new Coord(1.1*mid, 0, 1.1*mid);

    this.dishes = {};
    for (let i = 0; i &lt; this.cardinals.length; i++)
    {
        this.dishes[this.cardinals[i]] = {};
        for (let j = 0; j &lt; this.cardinals.length; j++)
        {
            let table = this.cardinals[i];
            let pos = this.cardinals[j];
            let pickID = i*10 + j;
            let coord = this.calculateCoord(table, pos);
            this.dishes[table][pos] = new Dish(coord, pickID, table, pos);
        }
    }

    this.pieces = [];
    for (let i = 0; i &lt; 40; i++)
    {
        let x = 1.55 + (~~(i / 10)) * 0.1;
        let y = 0.002;
        let z = -0.4 + (i % 10) * 0.1;
        let green = new Piece(new Coord(x, y, z), 'g', 100 + i);
        let black = new Piece(new Coord(-x, y, z), 'b', 200 + i);
        this.pieces.push(green, black);
    }

    this.waiter = {"table":'c', "pos":'c'};
    this.previousWaiter = {"table":'c', "pos":'c'};
};

Oolong.prototype.updatePickedElements = function(pickID)
{
    if (pickID > 0 &amp;&amp; pickID &lt; 100)
    {
        if (this.currentPickedDish != pickID &amp;&amp; this.running)
        {
            this.currentPickedDish = pickID;
            this.newPick = true;
        }
    }
    else if (pickID >= 100)
    {
        if (this.currentPickedPiece != pickID &amp;&amp; this.running)
        {
            this.currentPickedPiece = pickID;
            this.newPick = true;
        }
    }
};

/**
  * Calculates the 3D coordinate of a dish
  * @param {String} table - the cardinal coordinate of the table the dish belongs to
  * @param {String} pos - the position of the dish inside the table (cardinal coordinate)
  */
Oolong.prototype.calculateCoord = function(table, pos)
{
    let mid = Math.cos(Math.PI / 4);
    table = this.tables[table];
    switch(pos)
    {
        case 'n':
            return new Coord(table.x, table.y, table.z - 0.25);
        case 's':
            return new Coord(table.x, table.y, table.z + 0.25);
        case 'e':
            return new Coord(table.x + 0.25, table.y, table.z);
        case 'w':
            return new Coord(table.x - 0.25, table.y, table.z);
        case 'ne':
            return new Coord(table.x + 0.25*mid, table.y, table.z - 0.25*mid);
        case 'nw':
            return new Coord(table.x - 0.25*mid, table.y, table.z - 0.25*mid);
        case 'sw':
            return new Coord(table.x -0.25*mid, table.y, table.z + 0.25*mid);
        case 'se':
            return new Coord(table.x + 0.25*mid, table.y, table.z + 0.25*mid);
        case 'c':
            return new Coord(table.x, table.y, table.z);
    }
};

/**
  * Makes a request to the SICStus server, handling its answer using two inline functions
  * @param {String} requestString - the request
  */
Oolong.prototype.request = function(requestString)
{
    requestString = "request_" + requestString;
    let requestPort = 8081;
    let request = new XMLHttpRequest();
    let parent = this;

    request.open('GET', 'http://localhost:' + requestPort + '/' + requestString, true);
    request.onload = function(data)
    {
        let code = parseInt(data.target.response.split("/")[0]);
        let answer = data.target.response.split("/")[1];
        console.log("Code: " + code + "| Answer: " + answer);

        switch (code)
        {
            case 0:
                this.running = false;
                break;
            case 7:
                parent.board = answer;
                break;
            case 8:
                if (answer == "victory_black")
                {
                    parent.winner = "black";
                    parent.winnerIsSet = true;
                    parent.requestedWinner = false;
                    parent.readyForUpdate = true;
                }
                if (answer == "victory_green")
                {
                    parent.winner = "green";
                    parent.winnerIsSet = true;
                    parent.requestedWinner = false;
                    parent.readyForUpdate = true;
                }
                if (answer == "victory_none")
                {
                    parent.winner = "none";
                    parent.winnerIsSet = false;
                    parent.requestedWinner = false;
                    parent.readyForUpdate = true;
                }
                break;
            case 10:
                if (answer == "valid")
                    parent.moveIsValid = true;
                if (answer == "invalid")
                {
                    parent.moveIsValid = false;
                    parent.requestedMove = false;
                }
                break;
            case 11:
                parent.aiMoveReady = true;
                parent.aiMove = answer;
                break;
            case 12:
                parent.readyForAnimation = true;
                break;
            case 13:
                parent.previousWaiter.table = parent.waiter.table;
                parent.previousWaiter.pos = parent.waiter.pos;

                parent.waiter.table = answer.split('-')[0];
                parent.waiter.pos = answer.split('-')[1];
                parent.startCamera = true;
                break;
            case 14:
                if (answer == "human")
                    parent.currentPlayerType = "human";
                if (answer == "ai")
                    parent.currentPlayerType = "ai";
                parent.requestedPlayerType = false;
                break;
            case 15:
                if (answer == "b")
                    parent.currentPlayer = "black";
                if (answer == "g")
                    parent.currentPlayer = "green";
                parent.requestedPlayer = false;
                break;
            case 18:
                parent.tablesBlack = answer;
                parent.scene.tablesBlack = answer;
                parent.requestedTableBlack = false;
                break;
            case 19:
                parent.tablesGreen = answer;
                parent.scene.tablesGreen = answer;
                parent.requestedTableGreen = false;
                break;
            default:
                //other requests return only predetermined data with no useful situation
                break;
        }
    };
    request.onerror = function(data)
    {
        console.log("Unable to get server response");
        parent.running = false;
    };
    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
    request.send();
};

/**
  * Displays the current Oolong board
  */
Oolong.prototype.display = function()
{
    for (let pos in this.tables)
    {
        let coord = this.tables[pos];
        this.scene.pushMatrix();
        this.scene.translate(coord.x, coord.y, coord.z);
        this.graph.display("roundTable");
        this.scene.popMatrix();
    }

    for (let i = 0; i &lt; this.cardinals.length; i++)
    {
        for (let j = 0; j &lt; this.cardinals.length; j++)
        {
            let table = this.cardinals[i];
            let pos = this.cardinals[j];
            let coord = this.dishes[table][pos].coord;
            let id = this.dishes[table][pos].pickID;
            this.scene.pushMatrix();
            this.scene.translate(coord.x, coord.y, coord.z);
            this.graph.display("dish", id);
            this.scene.popMatrix();
        }
    }

    this.displayCurrentWinner();

    if (!this.running)
        return;

    for (let i = 0; i &lt; this.pieces.length; i++)
    {
        let coord = this.pieces[i].coord;
        let piece = this.pieces[i].color == 'g' ? "greenPiece" : "blackPiece";
        let id = this.pieces[i].pickID;
        this.scene.pushMatrix();

        if (this.currentPickedPiece.pickID == id &amp;&amp; this.readyForAnimation)
            this.scene.multMatrix(this.matrix);
        else
            this.scene.translate(coord.x, coord.y, coord.z);

        this.graph.display(piece, id);
        this.scene.popMatrix();
    }

    this.scene.pushMatrix();
    this.scene.translate(-1.7, 0, 0);
    this.graph.display("sideboard");
    this.scene.popMatrix();

    this.scene.pushMatrix();
    this.scene.translate(1.7, 0, 0);
    this.graph.display("sideboard");
    this.scene.popMatrix();

    this.scene.pushMatrix();
    let coord = this.calculateCoord(this.waiter.table, this.waiter.pos);
    this.scene.translate(coord.x, coord.y, coord.z);
    this.graph.display("waiter");
    this.scene.popMatrix();

    this.scene.pushMatrix();
    coord = this.calculateCoord('nw', 'c');
    this.scene.translate(coord.x - 0.9, coord.y - 0.01, coord.z - 0.9);
    this.scene.rotate(Math.PI / 4, 0, 1, 0);
    let number = this.tablesGreen.toString() + this.tablesBlack.toString();
    this.displayCounter(this.counterTables, number);
    this.scene.popMatrix();

    this.scene.pushMatrix();
    coord = this.calculateCoord('se', 'c');
    this.scene.translate(coord.x + 0.9, coord.y - 0.01, coord.z + 0.9);
    this.scene.rotate(Math.PI + Math.PI / 4, 0, 1, 0);
    number = this.tablesGreen.toString() + this.tablesBlack.toString();
    this.displayCounter(this.counterTables, number);
    this.scene.popMatrix();

    this.scene.pushMatrix();
    coord = this.calculateCoord('sw', 'c');
    this.scene.translate(coord.x - 0.9, coord.y - 0.01, coord.z + 0.9);
    this.scene.rotate(Math.PI - Math.PI / 4, 0, 1, 0);
    this.displayCounter(this.counterTimeout, this.scene.currentTimeout);
    this.scene.popMatrix();

    this.scene.pushMatrix();
    coord = this.calculateCoord('ne', 'c');
    this.scene.translate(coord.x + 0.9, coord.y - 0.01, coord.z - 0.9);
    this.scene.rotate(-Math.PI / 4, 0, 1, 0);
    this.displayCounter(this.counterTimeout, this.scene.currentTimeout);
    this.scene.popMatrix();

};

/**
  * Displays a counter
  * @param {Counter} counter - the counter to display
  * @param {Number} val - the value to set the counter to
  */
Oolong.prototype.displayCounter = function(counter, val)
{
    this.scene.pushMatrix();
    let mat = new CGFappearance(this.scene);
    mat.apply();
    this.scene.translate(-0.25, 0, -0.125);
    this.scene.scale(0.25, 0.25, 0.25);
    counter.display(val);
    this.scene.popMatrix();
};

/**
  * Undoes the last move
  */
Oolong.prototype.undo = function()
{
    console.log("Undo");
    let state = this.stateList.getPreviousState();
    let prologBoard = this.convertBoardToProlog(state.board);
    if (state != null)
    {
        this.request("set_board(" + prologBoard + ")");
        this.request("set_waiter(" + state.waiter + ")");
        this.resetState();
        this.setState(state);
    }
};

/**
  * Redoes the last cancelled move
  */
Oolong.prototype.redo = function()
{
    console.log("Redo");
    let state = this.stateList.getNextState();
    let prologBoard = this.convertBoardToProlog(state.board);
    if (state != null)
    {
        this.request("set_board(" + prologBoard + ")");
        this.request("set_waiter(" + state.waiter + ")");
        this.resetState();
        this.setState(state);
    }
};

/**
  * Changes the current board using a state
  * @param {State} state - the new state
  */
Oolong.prototype.setState = function(state)
{
    let waiter = state.waiter.split("-");
    this.waiter.table = waiter[0];
    this.waiter.pos = waiter[1];

    let board = state.board;
    this.resetAllPieces();
    for (let i = 0; i &lt; board.length; i++)
    {
        let dish = board[i];
        if (dish[2] != "o")
            this.placeRandomPiece(dish[2], dish[0], dish[1]);
    }
    this.readyForTurn = true;
};

/**
  * Parses a board from the notation returned by the server
  * into an array and adds it to the state list
  * @param {String} board - the board in the notation used by Prolog
  */
Oolong.prototype.parseBoard = function(board)
{
    let positions = board.split(",");
    for (let i = 0; i &lt; positions.length; i++)
    {
        positions[i] = positions[i].split("-");
        positions[i][0] = positions[i][0].replace("[", "");
        positions[i][1] = positions[i][1].replace("[", "");
        positions[i][2] = positions[i][2].replace("[", "");
        positions[i][0] = positions[i][0].replace("]", "");
        positions[i][1] = positions[i][1].replace("]", "");
        positions[i][2] = positions[i][2].replace("]", "");
    }
    let waiter = this.waiter.table + "-" + this.waiter.pos;
    this.stateList.addState(positions, waiter);
};

/**
  * Converts a board to the notation used by Prolog
  * @param {Array} board - the board to convert
  * @return {String} the converted board
  */
Oolong.prototype.convertBoardToProlog = function(board)
{
    let prologBoard = [];
    for (let i = 0; i &lt; board.length; i++)
    {
        let args = board[i].join("-");
        prologBoard.push(args);
    }
    let prologString = "[";
    prologString += prologBoard.join();
    prologString += "]";
    return prologString;
};

/**
  * Returns the currently picked dish
  * @return {Dish} the currently picked dish. null if no dish is picked
  */
Oolong.prototype.getPickedDish = function()
{
    for (let table in this.dishes)
    {
        for (let pos in this.dishes[table])
        {
            if (this.dishes[table][pos].pickID == this.currentPickedDish)
                return this.dishes[table][pos];
        }
    }
    return null;
};

/**
  * Returns the currently picked piece
  * @return {Piece} the currently picked piece. null if no piece is picked
  */
Oolong.prototype.getPickedPiece = function()
{
    let currPlayer = this.currentPlayer[0];
    let id = this.currentPickedPiece;

    for (let i = 0; i &lt; this.pieces.length; i++)
    {
        if (this.pieces[i].pickID == id &amp;&amp;
            !this.pieces[i].placed &amp;&amp;
            this.pieces[i].color == currPlayer)
            return this.pieces[i];
    }
    return null;
};

/**
  * Returns a random unplaced piece that belongs to the current player. Ends the game
  * if there isn't any piece left
  * @return {Piece} the selected piece
  */
Oolong.prototype.getRandomPiece = function()
{
    let currPlayer = this.currentPlayer[0];

    for (let i = 0; i &lt; this.pieces.length; i++)
    {
        if (!this.pieces[i].placed &amp;&amp; this.pieces[i].color == currPlayer)
            return this.pieces[i];

    }
    this.running = false;
};

/**
  * Unplaces all pieces and sets them back to their original positions
  */
Oolong.prototype.resetAllPieces = function()
{
    for (let i = 0; i &lt; this.pieces.length; i++)
    {
        this.pieces[i].coord = this.pieces[i].originalCoord;
        this.pieces[i].placed = false;
    }
};

/**
  * Places a random piece
  * @param {String} color - the color of the piece
  * @param {String} table - the table of the piece
  * @param {String} pos - the dish of the piece
  */
Oolong.prototype.placeRandomPiece = function(color, table, pos)
{
    if (table == "null" || pos == "null")
        return;
    for (let i = 0; i &lt; this.pieces.length; i++)
    {
        if (!this.pieces[i].placed &amp;&amp; this.pieces[i].color == color)
        {
            let coord = this.calculateCoord(table, pos);
            return this.pieces[i].place(table, pos, coord);
        }
    }
};

/**
  * Resigns the current player, making the other win
  */
Oolong.prototype.resignCurrentPlayer = function()
{
    this.running = false;
    this.winnerIsSet = true;
    this.winner = this.currentPlayer == "black" ? "green" : "black";
    console.log("Player " + this.winner + " wins!");
};

/**
  * Displays an orb with the winner, using a shader to inflate/deflate it
  */
Oolong.prototype.displayCurrentWinner = function()
{
    if (!this.running &amp;&amp; this.winnerIsSet)
    {
        this.scene.setActiveShader(this.scene.customShader);
        if (this.winner == "black")
            this.graph.display("victorySphereBlack");
        else if (this.winner == "green")
            this.graph.display("victorySphereGreen");
        this.scene.setActiveShader(this.scene.defaultShader);
    }
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Animation.html">Animation</a></li><li><a href="BezierAnimation.html">BezierAnimation</a></li><li><a href="CameraOrbiter.html">CameraOrbiter</a></li><li><a href="CircularAnimation.html">CircularAnimation</a></li><li><a href="ComboAnimation.html">ComboAnimation</a></li><li><a href="Coord.html">Coord</a></li><li><a href="Counter.html">Counter</a></li><li><a href="Dish.html">Dish</a></li><li><a href="Interface.html">Interface</a></li><li><a href="LinearAnimation.html">LinearAnimation</a></li><li><a href="ObjectGraph.html">ObjectGraph</a></li><li><a href="ObjectNode.html">ObjectNode</a></li><li><a href="ObjectTexture.html">ObjectTexture</a></li><li><a href="Oolong.html">Oolong</a></li><li><a href="Piece.html">Piece</a></li><li><a href="PrimitiveCylinder.html">PrimitiveCylinder</a></li><li><a href="PrimitiveNURBS.html">PrimitiveNURBS</a></li><li><a href="PrimitivePolygon.html">PrimitivePolygon</a></li><li><a href="PrimitiveRectangle.html">PrimitiveRectangle</a></li><li><a href="PrimitiveSphere.html">PrimitiveSphere</a></li><li><a href="PrimitiveTriangle.html">PrimitiveTriangle</a></li><li><a href="Scene.html">Scene</a></li><li><a href="SceneGraphParser.html">SceneGraphParser</a></li><li><a href="SimpleLinearAnimation.html">SimpleLinearAnimation</a></li><li><a href="State.html">State</a></li><li><a href="StateList.html">StateList</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Dec 31 2017 18:14:02 GMT+0000 (GMT Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
